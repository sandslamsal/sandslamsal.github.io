function testBasicReactions(){console.log("=== Testing Basic Reaction Calculations ===");const o=[{x:0,y:0},{x:3,y:0},{x:3,y:2},{x:0,y:2}],e=5e3,n=0,l=0;if(console.log("\nTest 1: Axial load only"),console.log("P =",e,"kN, Mx = My = 0"),console.log("4 piles at:",o.map(o=>`(${o.x},${o.y})`).join(", ")),Core.computeReactionsRigid){const t=Core.computeReactionsRigid({P:e,Mx:n,My:l,coords:o});console.log("Reactions:"),t.reactions.forEach(o=>{console.log(`  Pile ${o.index}: ${o.R.toFixed(2)} kN at (${o.x}, ${o.y})`)}),console.log(`Pmax: ${t.Pmax.toFixed(2)} kN`),console.log(`Pmin: ${t.Pmin.toFixed(2)} kN`);const s=t.reactions.reduce((o,e)=>o+e.R,0);console.log(`Sum of reactions: ${s.toFixed(2)} kN`),console.log(`Equilibrium error: ${Math.abs(s-e).toFixed(6)} kN`);const c=e/4,i=t.reactions.every(o=>Math.abs(o.R-c)<.001);console.log(`All reactions equal (${c} kN): ${i?"PASS":"FAIL"}`)}else console.log("Core.computeReactionsRigid not available");console.log("\nTest 2: With moment Mx = 2000 kN\u22c5m");const t=2e3;if(Core.computeReactionsRigid){const n=Core.computeReactionsRigid({P:e,Mx:t,My:l,coords:o});console.log("Reactions with moment:"),n.reactions.forEach(o=>{console.log(`  Pile ${o.index}: ${o.R.toFixed(2)} kN at (${o.x}, ${o.y})`)});n.cx;const s=n.cy;let c=0;n.reactions.forEach(o=>{c+=o.R*(o.y-s)}),console.log(`Applied Mx: ${t} kN\u22c5m`),console.log(`Calculated moment: ${c.toFixed(2)} kN\u22c5m`),console.log(`Moment equilibrium error: ${Math.abs(c-t).toFixed(6)} kN\u22c5m`)}}function testFlexureCalculations(){if(console.log("\n=== Testing Flexure Calculations ==="),Core.flexureCapacity){const o={Mu_kNm:800,b_m:1,d_m:.72,fc_MPa:35,fy_MPa:420,phi:.9};console.log("Input parameters:"),console.log(`  Mu = ${o.Mu_kNm} kN\u22c5m`),console.log(`  b = ${o.b_m} m`),console.log(`  d = ${o.d_m} m`),console.log(`  f'c = ${o.fc_MPa} MPa`),console.log(`  fy = ${o.fy_MPa} MPa`),console.log(`  \u03c6 = ${o.phi}`);const e=Core.flexureCapacity(o);console.log("Results:"),console.log(`  \u03c6Mn = ${e.phiMn_kNm.toFixed(2)} kN\u22c5m`),console.log(`  As,req = ${e.As_req_mm2.toFixed(0)} mm\xb2`),console.log(`  As,min = ${e.As_min_mm2.toFixed(0)} mm\xb2`);const n=e.phiMn_kNm>=o.Mu_kNm;console.log("  Capacity adequate: "+(n?"YES":"NO"))}else console.log("Core.flexureCapacity not available")}function testOneWayShear(){if(console.log("\n=== Testing One-Way Shear ==="),Core.oneWayShear){const o={Vu_kN:250,b_m:1,d_m:.72,fc_MPa:35,phi:.75};console.log("Input parameters:"),console.log(`  Vu = ${o.Vu_kN} kN`),console.log(`  b = ${o.b_m} m`),console.log(`  d = ${o.d_m} m`),console.log(`  f'c = ${o.fc_MPa} MPa`),console.log(`  \u03c6 = ${o.phi}`);const e=Core.oneWayShear(o);console.log("Results:"),console.log(`  \u03c6Vc = ${e.phiVc_kN.toFixed(2)} kN`),console.log(`  Utilization = ${e.util.toFixed(3)}`),console.log("  Adequate: "+(e.OK?"YES":"NO"))}else console.log("Core.oneWayShear not available")}function testIterativeRedistribution(){console.log("\n=== Testing Iterative Tension Redistribution ===");const o=[{x:0,y:0},{x:4,y:0},{x:4,y:2},{x:0,y:2}],e=3e3,n=3e3,l=0;if(console.log("Load case causing tension:"),console.log(`P = ${e} kN, Mx = ${n} kN\u22c5m, My = ${l} kN\u22c5m`),Core.computeReactionsRigid&&Core.computeReactionsIterative){const t=Core.computeReactionsRigid({P:e,Mx:n,My:l,coords:o});console.log("\nRegular analysis (allowing tension):"),t.reactions.forEach(o=>{const e=o.R<0?"(TENSION)":"";console.log(`  Pile ${o.index}: ${o.R.toFixed(2)} kN ${e}`)});const s=Core.computeReactionsIterative({P:e,Mx:n,My:l,coords:o});console.log("\nIterative analysis (tension eliminated):"),s.reactions.forEach(o=>{const e=o.R<0?"(TENSION)":0===o.R?"(INACTIVE)":"";console.log(`  Pile ${o.index}: ${o.R.toFixed(2)} kN ${e}`)});const c=s.reactions.some(o=>o.R<-.001);console.log("\nTension eliminated: "+(c?"NO":"YES"));const i=s.reactions.reduce((o,e)=>o+e.R,0);console.log("Force equilibrium: "+(Math.abs(i-e)<.01?"YES":"NO"))}else console.log("Iterative functions not available")}const fs=require("fs"),path=require("path");"undefined"==typeof global&&(global={}),global.window={};const corePath=path.join(__dirname,"pilecap-core.js");let Core;if(fs.existsSync(corePath))try{Core=require("./pilecap-core.js")}catch(e){const coreCode=fs.readFileSync(corePath,"utf8");eval(coreCode),Core=global.PileCapCore}else console.error("Core module not found:",corePath),Core={};console.log("Pile Cap Core Calculation Verification\n");try{testBasicReactions(),testFlexureCalculations(),testOneWayShear(),testIterativeRedistribution(),console.log("\n=== Verification Complete ==="),console.log("Check results above for any FAIL indicators.")}catch(o){console.error("Error during verification:",o.message),console.log("This script requires the core module to be properly loaded.")}